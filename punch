#!/bin/bash -eu
###############################################################################
# Punch
# A script to bootstrap, query and control AWS EC2 instances.
# 
# Copyright 2017 Karl von Randow
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
###############################################################################

PUNCH_LIB_DIR="$(dirname $0)/lib"
. "$PUNCH_LIB_DIR"/image.sh

usage() {
	cat >&2 <<EOF
usage: $0 [-f <config file>] [-d] <command>
    -f Configuration file containing environment variables
    -d Dry run mode
    -q Quiet mode

    Global environment variables (optional):
        PROFILE             The aws-cli profile to use (see aws configure)
        REGION              The AWS region to use

Run command:
        run [-i <image-id>] [-c <count>] [-n <name>] [-t <key=value>] [-o <client token>]

    Run environment variables (required):
        AMI                 The image-id for the new instance
     or IMAGE               "<distro> <filters>"

        The supported distros are:
          * ubuntu

        After the distro name you MAY include filters:
          * release (e.g. focal)
          * architecture (default: x86_64)
          * root_device_type (default: ebs)
          * image_type (default: machine)
          * hypervisor (default: xen)
          * virtualization_type (default: hvm)
          * volume_type (e.g. gp2)
          * owner (defaults to official owner for the distro)

    Run environment variables (optional):
        NAME                The EC2 instance name
        INSTANCE_TYPE       The EC2 instance type
        KEY_NAME            The name of the key-pair to associate with the new instance
        SECURITY_GROUP      The VPC security group id
        SUBNET              The VPC subnet id
        ASSOCIATE_PUBLIC_IP_ADDRESS If not empty, associate a public IP address with the new instance
        COUNT               The number of instances to create
        TAGS                One or more tags to set on the new instances, e.g. name=value
        ROOT_VOLUME_SIZE    The size of the root volume in GiB

    Bootstrap environment variables (optional):
        PRIVATE_KEY_FILE    Path to an SSH private key file to deploy to the server
        BOOTSTRAP_GIT_URL   URL to a git repository to clone on the new instance
        BOOTSTRAP_GIT_DIR   Path to clone the git repository to on the new instance
        BOOTSTRAP_SCRIPT    Commands to be executed on the new instance while bootstrapping

    Bootstrap environment variables (advanced):
        BOOTSTRAP_TEMPLATE  Path to the template file to use for the bootstrap script

Query commands:
        instances [<instance id or name> ...]
        ip [<instance id or name> ...]

    Query command options:
        -f <filters>        See aws ec2 run-instances help
        -g <group ids>      AWS VPC security group ids
        -n <name>           The instance name
        -t <key=value> or <key> or <=value>    Tag key/value, or just key, or just value
        -i <instance id> ...
        -r                  Include only running or pending instances
        -o <client token>   Include only instances with the given client token

Control commands:
        ssh [<instance> ...] [-c <command>]
        scp <instance>:<source path> <local dest path>    Copy from an instance
        scp <local source path> [<instance>]:<dest path>  Copy to an instance, or all matching instances
        csshX [<instance> ...]        Requires csshX to be installed
        terminate [<instance> ...]
        start [<instance> ...]
        stop [<instance> ...]

          Where <instance> is an instance id or instance name.

    Control command options:
        See query command options above
        -u <username>       The SSH username to connect with

    SSH environment variables (optional):
        IDENTITY            Path to an SSH key file matching the instance's key-pair
        USERNAME            The SSH username to connect with
EOF
	exit 1
}

global_aws_options=
additional_aws_options=
quiet=0

findConfig() {
	local search_dir="$PWD"
	while [ ! -f "$search_dir/.punch.cfg" -a "$search_dir" != "/" ]; do
		search_dir="$(dirname $search_dir)"
	done

	if [ -f "$search_dir/.punch.cfg" ]; then
		echo "$search_dir/.punch.cfg"
	fi
}

config_file=$(findConfig)
if [ ! -z "$config_file" ]; then
	set +e
	set -a # So all variables are exported, for the ones we pass to other commands like mo
	source "$config_file"
	if [ $? != 0 ]; then
		echo "Failed to source config file: $config_file" >&2
		exit 1
	fi
	set -e
	set +a
fi

while getopts ":f:dqh" opt; do
	case $opt in
		f)
			set -a # So all variables set are exported for our template engine
			source "$OPTARG"
			set +a
			;;
		d)
			additional_aws_options="${additional_aws_options:-} --dry-run"
			;;
		q)
			quiet=1
			;;
		h)
			usage
			;;
		\?)
			echo "Invalid option: -$OPTARG" >&2
			;;
	esac
done

shift $((OPTIND-1))
OPTIND=1 # Reset as we use OPTIND to track our progress through the args

announce() {
	if [ $quiet == 0 ]; then
		echo "$*" >&2
	fi
}

if [ ! -z "${PROFILE:-}" ]; then
	global_aws_options="$global_aws_options --profile $PROFILE"
fi
if [ ! -z "${REGION:-}" ]; then
	global_aws_options="$global_aws_options --region $REGION"
fi

command=${1:-}
if [ -z "$command" ]; then
	usage
fi
shift

command_run() {
	while getopts ":c:n:t:i:o:" opt; do
		case $opt in
			c)
				COUNT="$OPTARG"
				;;
			n)
				tags="${tags:-} Key=Name,Value=\"$OPTARG\""
				;;
			t)
				tag_key=$(echo "$OPTARG" | cut -d = -f 1)
				tag_value=$(echo "$OPTARG" | cut -d = -f 2)
				tags="${tags:-} Key=$tag_key,Value=$tag_value"
				;;
			i)
				AMI="$OPTARG"
				;;
			o)
				client_token="$OPTARG"
				;;
			\?)
				echo "Invalid option: -$OPTARG" >&2
				;;
		esac
	done

	shift $((OPTIND-1))

	if [ -z "${AMI:-}" ]; then
		if [ -n "${IMAGE:-}" ]; then
			AMI=$(find_image_with_distro $IMAGE)
		else
			echo "AMI or IMAGE is required for run command, either via -i command-line option or AMI environment variable" >&2
			exit 1
		fi
	fi

	if [ ! -z "${TAGS:-}" ]; then
		for tag in $TAGS; do
			tag_key=$(echo "$tag" | cut -d = -f 1)
			tag_value=$(echo "$tag" | cut -d = -f 2)
			tags="${tags:-} Key=$tag_key,Value=$tag_value"
		done
	fi
	if [ -n "${NAME:-}" ]; then
		tags="${tags:-} Key=Name,Value=$NAME"
	fi

	# Configuration
	set -a # So all variables set are exported for our template engine

	if [ -f "${BOOTSTRAP_PRIVATE_KEY_FILE:-}" ]; then
		BOOTSTRAP_PRIVATE_KEY=$(cat "$BOOTSTRAP_PRIVATE_KEY_FILE")
	fi

	if [[ "${BOOTSTRAP_GIT_URL:-}" =~ .*@.*:.* ]]; then
		BOOTSTRAP_GIT_SSH_HOST=$(echo "$BOOTSTRAP_GIT_URL" | sed -e s/.*@// -e s/:.*//)
	fi

	set +a

	# https://github.com/tests-always-included/mo
	MO="$PUNCH_LIB_DIR"/mo/mo
	BOOTSTRAP_TEMPLATE=${BOOTSTRAP_TEMPLATE:-$(dirname $0)/share/bootstrap.sh}

	BOOTSTRAP=$("$MO" "$BOOTSTRAP_TEMPLATE")

	local run_options=
	if [ ! -z "${KEY_NAME:-}" ]; then
		run_options="$run_options --key-name $KEY_NAME"
	fi
	if [ ! -z "${SUBNET:-}" ]; then
		run_options="$run_options --subnet-id $SUBNET"
	fi
	if [ ! -z "${INSTANCE_TYPE:-}" ]; then
		run_options="$run_options --instance-type $INSTANCE_TYPE"
	fi
	if [ ! -z "${SECURITY_GROUP:-}" ]; then
		run_options="$run_options --security-group-ids $SECURITY_GROUP"
	fi
	if [ ! -z "${ASSOCIATE_PUBLIC_IP_ADDRESS:-}" ]; then
		run_options="$run_options --associate-public-ip-address"
	fi
	if [ ! -z "${client_token:-}" ]; then
		run_options="$run_options --client-token $client_token"
	fi
	if [ ! -z "${ROOT_VOLUME_SIZE:-}" ]; then
		local root_volume_device_name=$(aws ec2 describe-images $global_aws_options --image-ids "$AMI" --output text --query 'Images[].BlockDeviceMappings[0].DeviceName')
		run_options="$run_options --block-device-mappings DeviceName=$root_volume_device_name,Ebs={VolumeSize=$ROOT_VOLUME_SIZE}"
	fi

	instance_ids=$(PAGER= aws ec2 run-instances $additional_aws_options $global_aws_options --image-id "$AMI" \
		--count "${COUNT:-1}" $run_options \
		--user-data "$BOOTSTRAP" \
		--query "Instances[].InstanceId" --output text)

	echo $instance_ids

	# Add tags
	if [ ! -z "${tags:-}" ]; then
		PAGER= aws ec2 create-tags --profile "$PROFILE" --region "$REGION" --resources $instance_ids --tags $tags
	fi
}

add_tag_filter() {
	tag_key=$(echo "$1=" | cut -d = -f 1)
	tag_value=$(echo "$1=" | cut -d = -f 2)

	if [ ! -z "$tag_key" -a ! -z "$tag_value" ]; then
		filters="${filters:-} Name=tag:$tag_key,Values=$tag_value"
	elif [ ! -z "$tag_key" ]; then
		filters="${filters:-} Name=tag-key,Values=$tag_key"
	elif [ ! -z "$tag_value" ]; then
		filters="${filters:-} Name=tag-value,Values=$tag_value"
	fi
}

# Get command-line options common to control commands
control_options() {
	while getopts ":f:g:n:t:i:ro:u:c:" opt; do
		case $opt in
			f)
				filters="$OPTARG"
				;;
			g)
				filters="${filters:-} Name=instance.group-id,Values=$OPTARG"
				;;
			n)
				add_tag_filter "Name=\"$OPTARG\""
				;;
			t)
				add_tag_filter "$OPTARG"
				;;
			i)
				instance_ids="${instance_ids:-} $OPTARG"
				;;
			r)
				filters="${filters:-} Name=instance-state-name,Values=running,pending"
				;;
			o)
				filters="${filters:-} Name=client-token,Values=$OPTARG"
				;;
			u)
				USERNAME="$OPTARG"
				;;
			c)
				ssh_command="$OPTARG"
				;;
			\?)
				echo "Invalid command option: -$OPTARG" >&2
				;;
		esac
	done
}

add_configuration_filters() {
	if [ ! -z "${AMI:-}" ]; then
		filters="${filters:-} Name=image-id,Values=$AMI"
	fi
	if [ ! -z "${SECURITY_GROUP:-}" ]; then
		filters="${filters:-} Name=instance.group-id,Values=$SECURITY_GROUP"
	fi
	if [ ! -z "${SUBNET:-}" ]; then
		filters="${filters:-} Name=network-interface.subnet-id,Values=$SUBNET"
	fi
	if [ ! -z "${KEY_NAME:-}" ]; then
		filters="${filters:-} Name=key-name,Values=$KEY_NAME"
	fi
	if [ ! -z "${INSTANCE_TYPE:-}" ]; then
		filters="${filters:-} Name=instance-type,Values=$INSTANCE_TYPE"
	fi
	if [ ! -z "${TAGS:-}" ]; then
		for tag in $TAGS; do
			add_tag_filter "$tag"
		done
	fi
	if [ ! -z "${NAME:-}" ]; then
		add_tag_filter "Name=$NAME"
	fi
}

# describe ec2 instances
# usage: describe_instances <query>
describe_instances() {
	aws ec2 describe-instances $global_aws_options \
		--instance-ids ${instance_ids:-} \
		--filters ${filters:-} \
		--query $1 \
		--output text
}

get_ips() {
	# Choose the public IP address if there one, otherwise fall back to the private
	ips=$(describe_instances Reservations[].Instances[].[PublicIpAddress,PrivateIpAddress] | sed -e 's/None\s*//g' | awk '{ print $1 }')

	if [ -z "$ips" ]; then
		announce "No matching instances"
		exit 0
	fi
}

add_instance() {
	local instance="$1"
	if [[ "$instance" =~ ^i-[0-9a-fA-F]+$ ]]; then
		instance_ids="${instance_ids:-} $instance"
	else
		local instance_id
		instance_id=$(aws ec2 describe-instances $global_aws_options --filters Name=tag:Name,Values="$instance" --query Reservations[].Instances[].InstanceId --output text)
		
		if [ -n "$instance_id" ]; then
			instance_ids="${instance_ids:-} $instance_id"
		else 
			echo "Failed to resolve instance name: $instance" >&2
			exit 1
		fi
	fi
}

clear_instances() {
	instance_ids=
}

get_instance_id_args() {
	shift $((OPTIND-1))

	local instance
	for instance in "$@" ; do
		if [[ "$instance" =~ ^- ]]; then
			break
		fi

		OPTIND=$((OPTIND + 1))

		add_instance "$instance"
	done
}

ssh_options() {
	while getopts ":c:" opt; do
		case $opt in
			c)
				ssh_command="$OPTARG"
				;;
			\?)
				echo "Invalid ssh option: -$OPTARG" >&2
				;;
		esac
	done
}

warn_leftovers() {
	if [ -n "$*" ]; then
		echo "Invalid extra arguments: $*" >&2
	fi
}

command_ssh() {
	control_options "$@"
	add_configuration_filters
	get_instance_id_args "$@"
	ssh_options "$@"

	shift $((OPTIND-1))
	warn_leftovers "$@"

	# Only try to connect to running or pending instances
	filters="${filters:-} Name=instance-state-name,Values=running,pending"
	
	get_ips

	ssh_options=-t
	if [ ! -z "${IDENTITY:-}" ]; then
		ssh_options="$ssh_options -i $IDENTITY"
	fi
	if [ ! -z "${USERNAME:-}" ]; then
		ssh_options="$ssh_options -l $USERNAME"
	fi
	ssh_options="$ssh_options -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

	for ip in $ips ; do
		announce "*** ssh $ip"
		/usr/bin/ssh $ssh_options "$ip" "${ssh_command:-}"
	done
}

command_scp() {
	control_options "$@"
	add_configuration_filters

	shift $((OPTIND-1))

	# Only try to connect to running or pending instances
	filters="${filters:-} Name=instance-state-name,Values=running,pending"

	ssh_options=
	if [ ! -z "${IDENTITY:-}" ]; then
		ssh_options="$ssh_options -i $IDENTITY"
	fi
	ssh_options="$ssh_options -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

	source=$(echo $* | awk {'print $1'})
	dest=$(echo $* | awk {'print $2'})

	if [ -z "$source" -o -z "$dest" ]; then
		usage
	fi

	local source_prefix=

	if [[ "$source" =~ ^([^:]*):(.*)$ ]]; then
		local source_instance=${BASH_REMATCH[1]}
		if [ -z "$source_instance" ]; then
			echo "scp source instance missing: $source" >&2
			exit 1
		fi

		source=${BASH_REMATCH[2]}

		clear_instances
		add_instance "$source_instance"
		get_ips
		source_prefix="$ips:"

		if [ ! -z "${USERNAME:-}" ]; then
			source_prefix="$USERNAME@$source_prefix"
		fi
	fi
	if [[ "$dest" =~ ^([^:]*):(.*)$ ]]; then
		local dest_instance=${BASH_REMATCH[1]}
		dest=${BASH_REMATCH[2]}

		# If dest_instance is empty then it means all matching servers, so we fall through
		if [ -n "$dest_instance" ]; then
			clear_instances
			add_instance "$dest_instance"
			get_ips
		elif [ -n "$source_prefix" ]; then
			echo "scp: dest cannot be empty if source is not local" >&2
			exit 1
		else
			get_ips
		fi
	elif [ -z "$source_prefix" ]; then
		echo "scp: either source or dest must be remote" >&2
		exit 1
	fi

	local dest_prefix=
	if [ -z "$source_prefix" ]; then
		if [ ! -z "${USERNAME:-}" ]; then
			dest_prefix="$USERNAME@"
		fi

		for ip in $ips ; do
			announce "*** scp $source $dest_prefix$ip:$dest"
			/usr/bin/scp $ssh_options -r "$source" "$dest_prefix$ip:$dest"
		done
	else
		announce "*** scp $source_prefix$source $dest_prefix$dest"
		/usr/bin/scp $ssh_options -r "$source_prefix$source" "$dest_prefix$dest"
	fi
}

command_csshX() {
	control_options "$@"
	add_configuration_filters
	get_instance_id_args "$@"

	# Only try to connect to running or pending instances
	filters="${filters:-} Name=instance-state-name,Values=running,pending"

	get_ips

	shift $((OPTIND-1))

	csshX_options=
	ssh_options=
	if [ ! -z "${IDENTITY:-}" ]; then
		ssh_options="$ssh_options -i $IDENTITY"
	fi
	if [ ! -z "${USERNAME:-}" ]; then
		csshX_options="$csshX_options --login $USERNAME"
	fi
	ssh_options="$ssh_options -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -q"

	csshX $csshX_options --ssh_args "$ssh_options" $ips
}

get_instance_ids() {
	instance_ids=$(describe_instances "Reservations[].Instances[].InstanceId")

	if [ -z "$instance_ids" ]; then
		announce "No matching instances"
		exit 0
	fi
}

command_terminate() {
	control_options "$@"
	get_instance_id_args "$@"

	shift $((OPTIND-1))

	if [ -z "${instance_ids:-}" ]; then
		# No instance_ids specified, so we query for them
		if [ -z "${filters:-}" ]; then
			# Default to skip already terminated instances, so we don't report their instance-ids
			filters="${filters:-} Name=instance-state-name,Values=running,pending,stopping,stopped"
		fi

		add_configuration_filters
		get_instance_ids
	fi

	PAGER= aws ec2 terminate-instances $additional_aws_options $global_aws_options \
		--instance-ids $instance_ids \
		--query TerminatingInstances[].InstanceId \
		--output text
}

command_start() {
	control_options "$@"
	get_instance_id_args "$@"

	shift $((OPTIND-1))

	if [ -z "$instance_ids" ]; then
		# No instance_ids specified, so we query for them
		if [ -z "${filters:-}" ]; then
			# Default to skip instances that aren't stopped
			filters="${filters:-} Name=instance-state-name,Values=stopping,stopped"
		fi

		add_configuration_filters
		get_instance_ids
	fi

	aws ec2 start-instances $additional_aws_options $global_aws_options \
		--instance-ids $instance_ids \
		--query StartingInstances[].InstanceId --output text
}

command_stop() {
	control_options "$@"
	get_instance_id_args "$@"

	shift $((OPTIND-1))

	if [ -z "$instance_ids" ]; then
		# No instance_ids specified, so we query for them
		if [ -z "${filters:-}" ]; then
			# Default to skip already stopped or terminated instances, so we don't report their instance-ids
			filters="${filters:-} Name=instance-state-name,Values=running,pending"
		fi

		add_configuration_filters
		get_instance_ids
	fi

	aws ec2 stop-instances $additional_aws_options $global_aws_options \
		--instance-ids $instance_ids \
		--query StoppingInstances[].InstanceId --output text
}

command_ip() {
	control_options "$@"
	add_configuration_filters
	get_instance_id_args "$@"
	shift $((OPTIND-1))

	get_ips
	echo $ips
}

command_instances() {
	control_options "$@"
	add_configuration_filters
	get_instance_id_args "$@"

	shift $((OPTIND-1))

	result=$(describe_instances 'Reservations[].Instances[].[InstanceId,PublicIpAddress,PrivateIpAddress,State.Name,Tags[?Key==`Name`]|[0].Value]')

	if [ -z "$result" ]; then
		announce "No matching instances"
		exit 0
	fi
	echo "$result"
}

case $command in
	run)
		command_run "$@"
		;;
	ssh)
		command_ssh "$@"
		;;
	scp)
		command_scp "$@"
		;;
	csshX)
		command_csshX "$@"
		;;
	terminate)
		command_terminate "$@"
		;;
	start)
		command_start "$@"
		;;
	stop)
		command_stop "$@"
		;;
	ip|ips)
		command_ip "$@"
		;;
	instances)
		command_instances "$@"
		;;
	*)
		echo "Unsupported command: $command" >&2
		usage
		;;
esac
